<?xml version="1.0"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.2//EN' 
              'http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd'
[
<!ENTITY two-theta "
    <inlinemediaobject>
     <imageobject><imagedata fileref='fitykhelp_img/2theta.png'/></imageobject>
     <textobject><phrase>2theta</phrase></textobject>
    </inlinemediaobject> 
  ">
]>
<!-- XML header above -->
<!-- SGML header below-->
<!-- <!DOCTYPE article  PUBLIC "-//OASIS//DTD DocBook V4.1//EN"> -->

<!-- the first version of this manual was created with LyX -->
<book lang="en">
 <title>Fityk - User's Manual</title> 
 <bookinfo> 
  <date>2006-01-07</date>
  <author> 
   <firstname>Marcin</firstname> <surname>Wojdyr</surname>
  </author> 
 </bookinfo>

 <chapter> 
  <title>Introduction</title> 
  <section>
   <title>What is the program for?</title>
   <para>
    <application>Fityk</application> is a program 
    for nonlinear fitting of analytical functions (especially peak-shaped) 
    to data (usually experimental data). The shortest description:
    peak fitting software. There are also people using it only
    to display data or to remove baseline from data.
   </para>
   <para>
    It is reported to be used in crystallography, 
    chromatography, photoluminescence, infrared and Raman spectroscopy
    and other fields. Although author is ignorant about all these experimental
    methods but powder diffraction, 
    he would like to make it useful for as many people as possible.
   </para>
   <para>
    <application>Fityk</application> offers various nonlinear fitting methods, 
    easy background subtracting and other dataset manipulations, 
    easy placement of peaks and changing peak parameters, 
    support for analyzing series of datasets,
    automation of common tasks with scripts, and much more. 
    The main advantage of the program is a flexibility - parameters
    of peaks can be arbitrarily binded with each other, 
    eg. width of the peak can be an independent variable, 
    can be the same as the width of the other peak 
    or can be given by complicated - common for all peaks - formula.
   </para> 
   <para>
    <application>Fityk</application> is free software; you can redistribute 
    and modify it under the terms of <acronym>GPL</acronym>, version 2. 
    See <xref linkend="license"/> for details. 
    You can download the latest version of <application>fityk</application> from
    <ulink url="http://www.unipress.waw.pl/fityk">
     http://www.unipress.waw.pl/fityk 
    </ulink>.
    or
    <ulink url="http://fityk.sf.net/">
     http://fityk.sf.net 
    </ulink>.
    To contact author, visit the same page. 
   </para> 
  </section>

  <section>
   <title>How to read this manual</title>
   <para>
    After this introduction, read the entire <xref linkend="using"/>.
    If you are using <acronym>GUI</acronym> you can look at 
    <ulink url="http://www.unipress.waw.pl/fityk/screenshots.html">
    screenshots-based tutorial at webpage 
    </ulink> 
    and postpone reading
    <xref linkend="CommandReference"/> until you need to write a script
    or understand better how the program works.
   </para>
  </section> 

  <section>
   <title><acronym>GUI</acronym> vs <acronym>CLI</acronym></title>
   <para>
    The program comes in two versions: <acronym>GUI</acronym> (Graphical User
    Interface) version - more comfortable for most users,
    and <acronym>CLI</acronym> (Command Line Interface) version 
    (named <command>cfityk</command> to differentiate, Unix only).
   </para>
   <para>
    If <acronym>CLI</acronym> version is compiled with 
    the <systemitem class="library">GNU Readline Library</systemitem>, 
    it enables command line editing and command history 
    like in <application>bash</application>.
    Especially useful is <keycap>TAB</keycap>-expanding. 
    Data and curve fitted to data are visualized with 
    <application>gnuplot</application> program (if it is installed).
   </para>
   <para>
    <acronym>GUI</acronym> version is written using 
    <ulink url="http://www.wxwidgets.org">
     <systemitem class="library">wxWidgets</systemitem> 
    </ulink>
    library. 
    One of the main features of this library is portability. Program can be
    run on most Unix species with <systemitem class="library">GTK+</systemitem>
    (it is developed on Linux) and on MS Windows. There are also people
    using it on MacOS X (have a look at fityk-users mailing list archives
    for details).
   </para>
  </section> 
 </chapter>


 <chapter id="using">
  <title>Getting started</title>

  <section>
   <title>The minimal example</title>
   <para>
    Let us analyze a diffraction pattern of NaCl. Our goal is to determine the
    position of the center of the highest peak. It is needed for calculating
    pressure, under which the sample was measured, but the further processing
    does not matter in our example.
   </para>
   <para>
    Data file used in this example is distributed with the program and 
    can be found in <filename class="directory">samples</filename> directory. 
   </para>
   <para>
    First load data from file <filename>nacl01.dat</filename>. 
    You can do it by typing <userinput>@0 &lt; nacl01.dat</userinput> 
    in <acronym>CLI</acronym> version (or in <acronym>GUI</acronym> version 
    in the input box - at the bottom, just above the status bar). 
    In <acronym>GUI</acronym>, you can select
    <menuchoice>
     <guimenu>Data</guimenu><guimenuitem>Load File</guimenuitem>
    </menuchoice> 
    from menu and choose proper file, instead. 
   </para> 
   <para>
    If you use GUI, you can zoom in the biggest peak 
    using <mousebutton>left</mousebutton> mouse button on the auxiliary plot
    (the plot below main plot). 
    To zoom out, press <guiicon>View whole</guiicon> toolbar button.
    Other ways of zooming are described in <xref linkend="mouse"/>. 
    If you want the data to be drawn with 
    bigger points or line, or if you want to change color of line or background,
    press <mousebutton>right</mousebutton> mouse button on the main plot
    and use <guimenu>Data point size</guimenu> or <guimenu>Color</guimenu>
    menu from pop-up menu. To change color of data points, use right-hand
    panel.
   </para> 
   <para>
    Now all data points are active.
    Because only the biggest peak is our interest, the rest of points can be
    deactivated. Type: <userinput> a = (23.0 &lt; x &lt; 26.0) </userinput>
    or change to <firstterm>range</firstterm> mode (press 
    <guiicon> Data-Range Mode </guiicon>
    button on toolbar) and select range 
    to be deactivated with <mousebutton>right</mousebutton> mouse button.
   </para>
   <para>
    We see that our data has no background, we
    would have to worry about, so now we only have to define peak with 
    reasonable initial values of peak's parameter and fit it to data. We will
    use Gaussian. 
    To see it's formula, type: <userinput>info Gaussian</userinput>
    or look for it in the documentation (in <xref linkend="flist"/>). 
    By the way, most of commands can be abbreviated, 
    eg. you can type: <userinput>i Gaussian</userinput>. 
   </para>
   <para>
    To define peak, type: 
    <userinput>%p = Gaussian(~60000, ~24.6, ~0.2) -> F</userinput>
    or
    <userinput>%p = guess Gaussian</userinput>
    or select 
    <menuchoice><guilabel>Gaussian</guilabel></menuchoice> 
    from the list of functions on toolbar and press 
    <guiicon>
     auto-add 
     <!-- <inlinegraphic fileref="../src/img/clickadd.xpm"> -->
    </guiicon> 
    toolbar button.
    There are also other ways to add peak in <acronym>GUI</acronym>,
    try <firstterm>add-peak</firstterm> mode. 
    These mouse-driven ways give function names like %_1, %_2, etc.
   </para>
   <para>
    Now let us fit the function. Type: <userinput>fit</userinput> 
    or select 
    <menuchoice>
     <guimenu>Fit</guimenu><guimenuitem>Run</guimenuitem>
    </menuchoice> 
    from menu. 
   </para>
   <para>
    To see peak parameters, type: <userinput> info+ %p</userinput>
    or (in GUI) move the cursor to the top of the peak 
    and try out context menu (right button), or use right-hand panel.
   </para>
   <para>
    That is all. To do the same second time, you can write all the commands 
    to file, and use it as script: 
    <userinput>commands &lt; nacl01.fit</userinput>
    or select 
    <menuchoice>
     <guimenu>Session</guimenu><guimenuitem>Execute script</guimenuitem>
    </menuchoice> 
    from menu, or run program with the name of the script: 
    <prompt>bash$ </prompt><userinput>fityk nacl01.fit</userinput>
   </para>
  </section> 

  <section>
   <title>Invoking fityk </title>
   <para>
    On startup, the program executes a script from the
    <filename>$HOME/.fityk/init</filename> file.
    Then the program handles files given as arguments on command line.
    If the filename has extension ".fit" or the file starts with "# Fityk"
    string, it is assumed to be a script and executed.
    Other files are assumed to be a data files and are loaded by the program.
    There are also other parameters to CLI and GUI versions of the program.
    Option "-h" gives the full listing.
   </para>
  </section> 

  <section id="gui">
   <title>Graphical interface </title>
   <section>
    <title>Plots and other windows</title>
    <para>
     The window of <application>fityk</application> program consists 
     of (from the top): menu bar, 
     toolbar, main plot, auxiliary plot, output window, input field,
     status bar and of sidebar at right-hand side. 
     The input field allows to type and execute commands in
     similar way as it is done in <acronym>CLI</acronym> version. 
     The output window (which is configurable through pop-up menu)
     shows results. Actually all GUI commands are converted into text
     and visible in output window.
    </para>
    <para>
     The main plot can display
     data points, functions and/or the sum of all functions. Use pop-up
     menu (click <mousebutton>right</mousebutton> button on the plot) 
     to configure it. Colors of data points and functions can be changed
     using sidebar. 
    </para>
    <para>
     One of the most useful things which auxiliary plot can display 
     is the difference between data and the sum of functions. 
     The plot can be controlled by pop-up menu. I hope
     quick look at this menu and a minute of experiments will make
     all possibilities of the auxiliary plot clear.
    </para>
    <para>
     Sometimes it is useful to print effects of our fitting work. Hard copy
     will contain plots visible on the screen, scaled to fit the page. The only
     difference is that backgrounds of plots will be white (to not waste
     toner/ink). So it may be necessary to change color of axis or data to
     darker one.
    </para>
    <para>
     Configuration of GUI (visible windows, colors, etc.) can be saved using 
     <menuchoice>
      <guimenu>GUI</guimenu><guimenuitem>Save current config</guimenuitem>
     </menuchoice>. 
     Two different configurations can be saved, 
     what allows easy changing of colors
     for printing. On Unix platform, these configurations are stored 
     in file in user's home directory. 
     On Windows - they are stored in registry (perhaps in future they will 
     be also stored in file).
    </para>
   </section>

   <section id="mouse">
    <title>Mouse usage</title>
    <para>
     The usage of the mouse on menu, dialog windows, 
     input field and output window is
     intuitive, so the only topic described here is how to effectively
     operate mouse on plots.
    </para>
    <para>
     Let us start with the auxiliary plot. 
     <mousebutton>Right</mousebutton> button displays pop-up menu, 
     with <mousebutton>left</mousebutton> 
     button you can select range to be displayed - range on x axis. 
     Clicking with <mousebutton>middle</mousebutton> button (or with 
     <mousebutton>left</mousebutton> button and pressed <keycap>Shift</keycap>)
     will zoom it out and display all data. 
    </para>
    <para>
     On the main plot, meaning of the <mousebutton>left</mousebutton> and
     <mousebutton>right</mousebutton> mouse button depends on current 
     <firstterm>mode</firstterm>, that can be changed using toolbar or menu.  
     There are hints on the status bar.
     In normal mode, <mousebutton>left</mousebutton> button is used for
     zooming and <mousebutton>right</mousebutton> invokes pop-up menu.
     The same behaviour can be obtained in any mode by pressing
     <keycap>Ctrl</keycap> (or <keycap>Alt</keycap> or <keycap>Shift</keycap>).

     <mousebutton>Middle</mousebutton> 
     button can be used to select a rectangle that you want to zoom in. 
     If an operation has two steps, like rectangle zooming (first you 
     press button to select first corner, then you move mouse and release 
     button to select second corner of rectangle),
     you can cancel it by pressing another button when first one is pressed.
    </para>
   </section> 
  </section> 
 </chapter>


 <chapter id="CommandReference">
  <title>Reference </title>
  <section id="GeneralSyntax">
   <title>General syntax </title>
   <para>
    Basically, there is one command is in one line. 
    If, for some reasons, it is more comfortable to place more than one
    command in one line, they can be separated with semicolon (;). 
   </para>
   <para>
    Most of the commands can have arguments separated by comma (,), 
    eg. <command>delete %a, %b, %c</command>. 
   </para>
   <para>
    Most of the commands can be shortened: eg. you can type 
    <command>inf</command> or <command>in</command> or <command>i</command>
    instead of <command>info</command>.
   </para>
   <para>
    Symbol '#' starts a comment - everything from
    hash (#) to the end of the line is ignored.
   </para>
  </section>

  <section>
   <title>Data from experiment </title>
   <section id="DataLoad">
    <title>Storing and loading data </title>
    <para>
     Data are stored in files.  Unfortunately, there are various formats of
     files with data. The basic one is text file with every line 
     corresponding to one data point. The line should contain at least two
     numbers: x and y of point. It can also contain standard deviation of y
     coordinate.  Numbers can be separated by whitespace, commas, colons or
     semicolons. Some lines can contain comments or extra informations. If
     these lines have a hash (#) in first column, they are ignored. In other
     case, they are also ignored (unless they can be read as data point). 
     There are also other file types, that can be read: .rit, .cpi,
     Siemens-Bruker.raw and .mca. In future, the way the special file formats
     are handled will be changed.
    </para>
    <para>
     Points are loaded from files using command
    </para>
    <cmdsynopsis>
     <arg choice="plain"><replaceable>dataslot</replaceable></arg>
     <command>&lt;</command> 
     <arg choice="plain"><replaceable>filename</replaceable></arg> 
     <arg><replaceable>filetype</replaceable></arg>  
     <arg><replaceable>xcol</replaceable>,<replaceable>ycol</replaceable>
      <arg>,<replaceable>scol</replaceable></arg>
     </arg> 
    </cmdsynopsis>
    <para>
     where 
     <replaceable>dataslot</replaceable> 
     should be replaced with <userinput>@0</userinput>, 
     unless many datasets are to be used simultanously 
     (for details see: <xref linkend="multidata"/>),
     <replaceable>filetype</replaceable> can be omitted (at this moment,
     due to small number of supported formats, the filetype can be
     detected automatically),
     <replaceable>xcol</replaceable>, <replaceable>ycol</replaceable>, 
     <replaceable>scol</replaceable>, 
     are unsigned integers. If the filename contains blank characters,
     semicolon or comma, it should be put inside of single
     quotation marks. If the file is in a text format (columns with numbers)
     it can be specified which column contains x, y and, optionally, std. dev.
     of y. 
    </para>
    <para>
     Command
     <cmdsynopsis>
      <arg choice="plain"><replaceable>dataslot</replaceable></arg>
      <command>&gt;</command> 
      <arg choice="plain"><replaceable>filename</replaceable></arg> 
     </cmdsynopsis>
     can export data to 3-column (x, y and standard deviation) ASCII file. 
     Only active points are being exported (see next chapter to learn about 
     active and inactive points).
    </para>
    <para>
     Some information about current data can be obtained using command:
    </para>
    <cmdsynopsis>
     <command>info</command>
     <arg choice="plain"><replaceable>dataslot</replaceable></arg>
    </cmdsynopsis>
   </section> 

   <section>
    <title>Active and inactive points</title>
    <para>
     We often have situation, that only part of data from file is interesting
     for us.  We should be able to exclude selected points from fitting and all
     computations. Every point can be either active or inactive.  
     It can be done with command <command>A=...</command> 
     (see <xref linkend="transform"/> for details)
     or with <link linkend="mouse">mouse-click in <acronym>GUI</acronym></link>.
     The idea of active and inactive points is simple: 
     only the active ones are subject to fitting and peak-finding, 
     inactive ones are neglected in these cases. 
    </para>
   </section> 

   <section>
    <title>Standard deviation or weight </title>
    <para>
     When fitting data, we assume that only y coordinate of data is subject to
     statistical errors in measurement. It is very common assumption. 
     To see how y standard deviation
     <inlinemediaobject>
      <imageobject><imagedata fileref="fitykhelp_img/sigma.png"/></imageobject>
      <textobject><phrase>sigma</phrase></textobject>
     </inlinemediaobject>  
     influences fitting (optimization), look at
     weighted sum of squared residuals formula in <xref linkend="nonlinear"/>. 
     We can also think about weights of points -
     every point has a weight assigned, that is equal 
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/w_1_sigma.png"/>
       </imageobject>
       <textobject>
        <phrase>w<subscript>i</subscript>=1/sigma^2</phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>
    </para>
    <para>
     Standard deviation of points can be 
     <link linkend="DataLoad">read from file</link> together with x and y
     coordinates. Otherwise, it is set to max(sqrt(y), 1.0), 
     Setting std. dev. as a square root of value is common 
     and has theoretical grounds when y is the number of independent events.
     You can always change standard deviation, eg. make it equal for every
     point with command: <userinput>S=1</userinput>.
     See <xref linkend="transform"/> for details.
    </para>
   </section> 

   <section id="transform">  
    <title>Data transformations</title>
    <para>
     Every data point has four properties: x coordinate, y coordinate,
     standard deviation of y and active/inactive flag. Lower case 
     letters x, y, s, a stand for these properties before transformation,
     and upper case X, Y, S, A for the same properties after transformation.
     M stands for the number of points. 
     You can transform data using assignments.
     Command <userinput>Y=-y</userinput> will change the sign of y coordinate
     of every point. You can also apply transformation to selected points:
     <userinput>X[3]=1.2</userinput> will change point with index 3 
     (which is 4th point, because first has index 0),
     and <userinput>X[3...6]=1.2</userinput> will do the same for points with 
     indices 3, 4, 5, but not 6. <userinput>X[2...]=1.2</userinput>
     will apply transformation to point with index 2 and all next points.
     You can guess what <userinput>X[...6]=1.2</userinput> does.
     Most of operations are executed sequentially for points from the first 
     to the last one. n stands for the index of currently transformed point.
     The sequance of commands:
     <userinput>M=500; x=n/100; y=sin(x)</userinput>
     will generate the sinusoid dataset with 500 points. 
    </para>
    <para>
     Expressions can contain binary operators: +, -, *, /, ^,
     one argument functions:
     sqrt, exp, log10, ln, sin, cos, tan, atan, asin, acos, abs,
     round (rounds to the nearest integer),
     two arguments functions: min2, max2 (eg. max2(3,5) will give 5), 
     and ternary operator:
     <command>
      <replaceable>condition</replaceable> ? 
      <replaceable>expression1</replaceable> : 
      <replaceable>expression2</replaceable>
     </command>, which performs 
     <replaceable>expression1</replaceable> if condition is true 
     and <replaceable>expression2</replaceable> otherwise.
     Conditions can be built using boolean operators comparisions: 
     AND, OR, >, >=, &lt;, &lt;=, = (or ==), != (or &lt;>), TRUE, FALSE, NOT.
    </para>
    <para>
     And important note: all operations are performed on real numbers.
     Two numbers that differ less than epsilon=1e-9 
     ie. abs(a-b)&lt;epsilon, are considered equal. 
     Indices are also computed in real number domain, 
     and then rounded to nearest integer.
    </para>
    <para>
     Transformations can be joined with ampersand (&amp;), eg.
     <userinput>X=y&amp;Y=x</userinput> swaps axes.
    </para>
    <para>
     Before and after executing transformations, points are always 
     sorted according to x coordinate. You can change order of points
     using <command>order=<replaceable>t</replaceable></command>,
     where <replaceable>t</replaceable> is one of x, y, s, a, -x, -y, -s, -a.
     It only has a sense in sequence of transformations joined with &amp;,
     because after finishing transformation, points will be reordered again.
    </para>
    <para>
     Points can be deleted using following syntax:
     <command>delete[<replaceable>index-or-range</replaceable>]</command>
     or 
     <command>delete(<replaceable>condition</replaceable>)</command>
     and created simply by increasing value of M.
    </para>
    <para>
     There are two parametrized functions: spline and interpolate.
     The general syntax is: 
     <replaceable>parametrizedfunc</replaceable> 
     [<replaceable>param1</replaceable>, 
     <replaceable>param2</replaceable>](<replaceable>expression</replaceable>)
     eg. spline[22.1, 37.9, 48.1, 17.2, 93.0, 20.7](x) will give
     value of cubic spline interpolation through points (22.1, 37.9),
     (48.1, 17.2), ... in x.
     Function interpolation is similar, but give polyline interpolation.
     Spline function is used for manual background substraction in GUI.
    </para>
    <para>
     A few examples:
     <screen>     
     Y[1...] = Y[n-1] + y[n] # integrate

     x[...-1] = (x[n]+x[n+1])/2;  # reduces
     y[...-1] = y[n]+y[n+1];      # two times
     delete(n%2==1)               # number of points

     delete(not a) # delete inactive points

     X = 4*pi * sin(x/2*pi/180) / 1.54051 # changes x scale (2theta -> Q)
    </screen>     
    </para>
   </section> 

   <section id="multidata">
    <title>Working with many datasets</title>
    <para>
     Let call a set of data that usually comes from one file - a 
     <firstterm>dataset</firstterm>. 
     All operations described above assume that only one dataset.
     If there are more datasets created, it must be explicitly
     written which dataset the command is applied to, eg.
     <userinput>M=500 in @0</userinput>. Datasets have numbers
     and are referenced by '@' with the number, eg. @3.
     @* means all datasets, and <userinput>Y=y/10 in @*</userinput>
     will do what is expected to.
    </para>
    <para>
     Command
     <cmdsynopsis>
      <arg choice="plain">@+</arg>
      <command>&lt;</command> 
      <arg choice="plain"><replaceable>filename</replaceable></arg> 
      <arg><replaceable>filetype</replaceable></arg>  
      <arg><replaceable>xcol</replaceable>,<replaceable>ycol</replaceable>
       <arg>,<replaceable>scol</replaceable></arg>
      </arg> 
     </cmdsynopsis>
     will load dataset to new slot. Using @+ increases the number of datasets,
     and command <command>delete @<replaceable>n</replaceable></command>
     decreases it. It is also possible to duplicate dataset (command
     <command>@+ &lt; @<replaceable>n</replaceable></command>)
     or create new dataset as a sum of two or more existing ones 
     (command <command>@+ &lt; @<replaceable>n</replaceable> +
      @<replaceable>m</replaceable> + ...</command>).
    </para>
    <para>
     Each dataset has a separate <link linkend="sum">sum</link>, ie. a model
     that can be fitted to the data. It is explained in the next chapter.
    </para>
    <para>
     Each dataset has a title. It does not have to be unique.
     When loading file, a title is automatically created, either 
     using filename or it is read from the file (it depends on format
     of the file).
     It is used for exporting data -- some file formats require it.
     Title can be changed using command 
     <command>
      @<replaceable>n</replaceable>.title=<replaceable>new-title</replaceable>
     </command>. 
     To see title of dataset, 
     use <command>info @<replaceable>n</replaceable></command>.
    </para>
   </section> 
  </section> 


  <section id="sum">
   <title>Sum of fitted functions </title>
   <section id="sumintro">
    <title>Sum - Introduction</title>
    <para>
     The sum of functions S - curve that is fitted to data - is itself a
     function. The value of the whole sum is computed as a sum of functions,
     like Gaussians or polynomials, and can be given by formula:
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/sum_f.png"/>
       </imageobject>
       <textobject>
        <phrase>
         S = \sum<subscript>i</subscript> f<subscript>i</subscript>
        </phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>, 
     where f<subscript>i</subscript> is a function of x, and
     depends on a vector of parameters a. This vector contains all
     fitted parameters. 
     Because we often have the situation, that the error 
     in the x coordinate of data points can be modeled with function z(x; a),
     we introduce this term to sum:
     <informalequation>
      <mediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/sum_f_x_z.png"/>
       </imageobject>
       <textobject>
        <phrase>
         S(x;a) = \sum<subscript>i</subscript> f<subscript>i</subscript>
                                                                (x+z(x;a);a)
        </phrase>
       </textobject>
      </mediaobject>  
     </informalequation>
     where
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/z_x_a.png"/>
       </imageobject>
       <textobject>
        <phrase>
         z(x;a) = \sum<subscript>j</subscript> z<subscript>j</subscript>(x;a)
        </phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>
     . Note that the same z(x) is used in all functions.
    </para>
    <para>
     Now we will have a closer look at f<subscript>i</subscript> functions. 
     Every function f<subscript>i</subscript> has a type chosen from 
     function types available in the program. The same is true about
     functions z<subscript>i</subscript>.
     One of these types is the
     <emphasis>Gaussian</emphasis>. It has the following formula:
     <informalequation>
      <mediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/gauss_example.png"/>
       </imageobject>
       <textobject>
        <phrase>
         height exp[-ln(2) ((x-center)/hwhm)^2]
        </phrase>
       </textobject>
      </mediaobject>  
     </informalequation>
     There are three parameters of Gaussian. These parameters does not
     depend on x. There must be one <firstterm>variable</firstterm> 
     binded to each parameter.
    </para>
   </section>
   <section>
    <title>Variables</title>
    <para>
     Variables in Fityk have names prefixed with dollar ($).
     Variable is created by assigning a value to it, eg.
     <userinput>$foo=~5.3</userinput> 
     or <userinput>$c=3.1</userinput>
     or <userinput>$bar=5*sin($foo)</userinput>.
     $foo is here a so-called <firstterm>simple variable</firstterm>. 
     It is created by assigning
     to it real number prefixed with ~. The `~' means that value
     assigned to the variable can be changed when fitting sum to data.
     For people familiar with optimization techniques: 
     the number of defined simple variables is the number of dimensions
     of hyper-space we are looking for optimum in.
     Variable $c is actually a constant. $bar depends on the value of $foo.
     When $foo changes, the value of $bar also changes.
     Compound variables can be build using operators +, -, *, /, ^
     and functions sqrt, exp, log10, ln, sin, cos, tan, atan, asin, acos.
    </para>
    <para>
     Every simple parameter has a value and, optionally, domain.  
     Domain is used only by fitting algorithms, 
     which need to randomly initialize or change variables. 
     Genetic Algorithms are a good example.
     [TODO: setting domain is not implemented at this moment, but will
     be added soon]
    </para>
    <para>
     Variables can be used in data tranformations, 
     eg. <userinput>x[3]=$bar</userinput> and value of data expression
     can be used in variable definition, but it can be inside of braces,
     eg. <userinput>$bleh={M}</userinput> 
     or, to create simple variable: <userinput>$bleh=~{M}</userinput>.
    </para>
    <para>
     Sometimes it is useful to freeze variable, ie. to prevent it's
     changes in fitting. There is no special syntax for it, 
     but it can be done using data expressions in this way:
     <screen>
      $a = ~12.3 # $a is fittable
      $a = {$a}  # $a is not fittable
      $a = ~{$a}  # $a is fittable again
     </screen>
    </para>
    <para>
     It is also possible to define a variable as eg. 
     <userinput>$bleh=~9.1*exp(~2)</userinput>. In this case two simple
     variables will be created automatically. Automatically created
     variables are named $_1, $_2, $_3, etc.
    </para>
    <para>
     Variables can be deleted using command 
     <command>delete <replaceable>$variable</replaceable></command>.
    </para>
   </section>
   <section>
    <title>Function types and functions</title>
    <para>
     Let's go back to functions. Function types have names that start
     with upper case letter, eg. Linear or Voigt. Functions 
     (ie. function instances) have names prefixed with percent,
     eg. %func. Every function has a type and variables binded to its
     parameters. 
    </para>
    <para>
     To see list of available function types, use command 
     <command>info types</command>. 
     You can also use command
     <command>info <replaceable>typename</replaceable></command>, 
     eg. <userinput>info Pearson7</userinput> to see parameter names,
     default values and formula.
    </para>
    <para>
     Function can be created by giving type and a proper
     number of comma-separated variables in brackets, eg:
     <userinput>%f = Gaussian(~66254., ~24.7, ~0.264)</userinput>
     or
     <userinput>%f = Gaussian(~66254., $ctr, $b+$c+~0.14)</userinput>.
     Every expression, which is valid on right hand side of variable
     assignment, can be put as a variable.
     If it is not just a name of variable, an automatic variable is created.
     In the last example two variables are created.
    </para>
    <para>
     The second way is to give named parameters of function, in any order, eg.
     <userinput>%f = Gaussian(height=~66254., hwhm=~0.264, center=~24.7)
     </userinput>
     Function types can can have specified default values for
     some parameters, so this assignment is also valid:
     <userinput>
     %f = Pearson7(height=~66254., center=~24.7, fwhm=~0.264)
     </userinput>,
     although shape parameter of Pearson7 is not given.
    </para>
    <para>
     A deep copy of function (ie. all variables it dependends on
     are copied) can be made using command 
     <command>
      <replaceable>%function</replaceable>
      =copy(<replaceable>%anotherfunction</replaceable>)
     </command>
    </para>
    <para>
     Functions can be also created with command <command>guess</command>,
     as described in <xref linkend="guess"/>.
    </para>
    <para>
     You can change the variable binded to any of function parameters
     in this way:
     <screen>
      =-> %f = Pearson7(height=~66254., center=~24.7, fwhm=~0.264)
      New function %f was created.
      =-> %f[center]=~24.8
      =-> $h = ~66254
      =-> %f[height]=$h
      =-> info %f
      %f = Pearson7($h, $_5, $_3, $_4)
      =-> $h = ~60000 # variables are kept by name, this also changes %f
     </screen>
    </para>
    <para>
     Functions can be deleted using command 
     <command>delete <replaceable>%function</replaceable></command>.
    </para>
   </section> 
   <section>
    <title>Sum, F and Z</title>
    <para>
     As it was already written, each dataset has a separate sum. ie. a model
     that can be fitted to the data. 
     It can be seen in <link linkend="sumintro">formula above</link>,
     that the sum consists of functions f<subscript>i</subscript> 
     and z<subscript>i</subscript>. Each dataset has two sets named F and Z.
     They contain references to functions.
     Sum is constructed by telling which functions are in F and which in Z.
    </para>
    <para>
     In many cases Z can be fogotten. Then fitted curve is a sum of all
     functions in F. The functions can be listed with command 
     <command>info F</command>.
    </para>
    <para>
     Command 
     <command><replaceable>%function -&gt; F</replaceable></command>
     puts <replaceable>%function</replaceable> into F,
     command 
     <command><replaceable>%function -&gt; Z</replaceable></command>
     puts <replaceable>%function</replaceable> into Z,
     and command 
     <command><replaceable>%function -&gt; N</replaceable></command>
     removes <replaceable>%function</replaceable> from F or Z.
     If there is more than one dataset, F, Z and N must be prefixed
     with dataset number, eg.
     <command><replaceable>%function -&gt; @1.F</replaceable></command>
     or
     <command><replaceable>%function -&gt; @0.N</replaceable></command>.
     Following syntax is also valid:
     <screen>
      # create and add funtion to F
      %g = Gaussian(height=~66254., hwhm=~0.264, center=~24.7) -> @0.F
      # create automatically named funtion and add it to F
      Gaussian(height=~66254., hwhm=~0.264, center=~24.7) -> @0.F
      # clear F
      @0.F = 0
      # clear F and put three functions in it
      @0.F = %a, %b, %c
      # make @1.F the exact (shallow) copy of @0.F
      @1.F = @0.F
      # make @1.F a deep copy of @0.F (it means all functions and variables
      # are duplicated).
      @1.F = copy(@0.F)
     </screen>
    </para>
    <para>
     Sum can be exported as data points (.dat), mathematic formula (.formula)
     or peak parameters (.peaks) using command:
     <command>F &gt; <replaceable>filename</replaceable></command>, 
     where <replaceable>filename</replaceable> have one of extensions
     listed above.
    </para>
   </section> 
   <section id="guess">
    <title>Guessing peak location </title>
    <para>
     It is possible to guess peak location and add it to F with command:
     <command>
      <replaceable>%name</replaceable> =
      guess <replaceable>PeakType</replaceable>
      [<replaceable>x1</replaceable>:<replaceable>x2</replaceable>]
      in @<replaceable>n</replaceable>
     </command>, 
     eg. <userinput>guess Gaussian [22.1:30.5] in @0</userinput>.
     If the range is omitted, the whole dataset will be searched.
     Name of function is optional.
    </para>
    <para>
     Fityk offers only primitive algorithm for peak-detection. 
     It looks for highest point in given range, and than tries to find out 
     width of peak. 
    </para>
    <para>
     If the highest point is found near the boundary
     of the given range, it is very probable that it is not the peak top,
     and, if <link linkend="settings">the option</link> 
     <parameter class="option">can-cancel-guess</parameter> 
     is set true, the guess is canceled.
    </para>
    <para>
     There are two real-number options related to <command>guess</command>: 
     <parameter class="option">height-correction</parameter> and 
     <parameter class="option">width-correction</parameter>. 
     Default value of them is 1.
     The guessed height and width are multiplied by the values of these
     options respectively.
    </para>
   </section> 
   <section>
    <title>Displaying informations </title>
    <para>
     If you are using GUI, most of informations can be displayed 
     with mouse clicks. Otherwise, you can use <command>info</command>
     command. Using <command>info+</command> instead of <command>info</command>
     sometimes displays more datailed informations.
     Command 
     <command>info peaks <replaceable>range</replaceable></command>
     will show, where the <command>guess</command> command would find the peak.
     <command>info functions</command> lists all defined functions,
     and <command>info variables</command> - all variables.
     <command>info @<replaceable>n</replaceable>.F</command> 
     and <command>info @.<replaceable>n</replaceable>Z</command> show 
     informations about F and Z, 
     <command>info @.<replaceable>n</replaceable>formula</command>
     shows mathematic formula of fitted function,
     and 
     <command>
      info @.<replaceable>n</replaceable> dF(<replaceable>x</replaceable>)
     </command>
     compares symbolic and numeric defivatives in <replaceable>x</replaceable>
     (useful only for debugging).
    </para>
   </section> 
  </section>

  <section>
   <title>Fitting </title>
   <section id="nonlinear">
    <title>Nonlinear optimization </title>
    <para>
     This is the core. We have a set of observations (data points), 
     and we want to fit a <firstterm>model</firstterm> (sum of functions), 
     that depends on adjustable parameters, to observations. 
     Let me quote <citetitle pubwork="book">Numerical Recipes</citetitle>, 
     chapter 15.0, page 656 (if you do not know the book, visit 
     <ulink url="http://www.nr.com">http://www.nr.com </ulink>):
    </para>
    <blockquote>
     <para>
      The basic approach in all cases is usually the same: You choose or design
      a figure-of-merit function (merit function, for short) that measures the
      agreement between the data and the model with a particular choice of
      parameters. The merit function is conventionally arranged so that small
      values represent close agreement. The parameters of the model are then
      adjusted to achieve a minimum in the merit function, yielding best-fit
      parameters.  The adjustment process is thus a problem in minimization in
      many dimensions.  [...] however, there exist special, more
      efficient, methods that are specific to modeling, and we will discuss
      these in this chapter. There are important issues that go beyond the mere
      finding of best-fit parameters. Data are generally not exact. They are
      subject to measurement errors (called noise in the context of
      signal-processing). Thus, typical data never exactly fit the model that
      is being used, even when that model is correct. We need the means to
      assess whether or not the model is appropriate, that is, we need to test
      the goodness-of-fit against some useful statistical standard. We usually
      also need to know the accuracy with which parameters are determined by
      the data set.  In other words, we need to know the likely errors of the
      best-fit parameters. Finally, it is not uncommon in fitting data to
      discover that the merit function is not unimodal, with a single minimum.
      In some cases, we may be interested in global rather than local
      questions. Not, "how good is this fit?" but rather, "how
      sure am I that there is not a very much better fit in some corner of
      parameter space?"
     </para>
    </blockquote>
    <para>
     Our function of merit is <acronym>WSSR</acronym> - weighted sum of
     squared residuals, called also chi-square:
     <informalequation>
      <mediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/chi2.png"/>
       </imageobject>
       <textobject>
        <phrase>
         chi<superscript>2</superscript> 
         = sum<subscript>i=1</subscript><superscript>N</superscript>
         [(y<subscript>i</subscript> - y(x<subscript>i</subscript>;a))
         /sigma<subscript>i</subscript>]<superscript>2</superscript>
         = sum<subscript>i=1</subscript><superscript>N</superscript>
         w<superscript>i</superscript>
         [y<subscript>i</subscript> - y(x<subscript>i</subscript>;a)]
         <superscript>2</superscript>
        </phrase>
       </textobject>
      </mediaobject>  
     </informalequation>
     Weights can be are based on standard deviations, 
     <inlineequation>
      <inlinemediaobject>
       <imageobject>
        <imagedata fileref="fitykhelp_img/w_1_sigma.png"/>
       </imageobject>
       <textobject>
        <phrase>w<subscript>i</subscript>=1/sigma^2</phrase>
       </textobject>
      </inlinemediaobject>  
     </inlineequation>.
     You can learn why squares of residuals are
     minimized eg. from chapter 15.1 of 
     <citetitle pubwork="book">Numerical Recipes</citetitle>. So we
     are looking for a global minimum of chi<superscript>2</superscript>. 
     This large field of numerical research - looking for minimum or maximum -
     is usually called optimization; it is non-linear and global optimization. 
     <application>Fityk</application> implements
     three very different optimization methods. All are well-known and
     described in many book. 
    </para>
   </section>

   <section>
    <title>Fitting related commands </title>
    <para>
     To fit sum to data, use command
     <cmdsynopsis>
      <command>fit</command> 
      <arg>+</arg> 
      <arg><replaceable>number-of-iterations</replaceable></arg> 
      <arg>in <replaceable>@n, ...</replaceable></arg> 
     </cmdsynopsis>
     Plus (+) means that fitting method is not initialized. It is used
     to continue previous fitting. 

     All non-linear fitting methods are iterative. 
     <replaceable>number-of-iterations</replaceable> 
     is the maximum number of iterations. There are also other 
     stopping criteria, so the number of executed iterations can be smaller.
    </para>
    <para>
     Fitting methods can be set using set command:
     <command>set fitting-method = <replaceable>method</replaceable></command>,
     where method is one of: Levenberg-Marquardt, Nelder-Mead-simplex,
     Genetic-Algorithms.
    </para>
    <para>
     <note>
      <para>
       The rest of this chapter is outdated,
       At this moment default settings of fitting methods can't be changed.
       It will be fixed as soon as possible.
      </para>
     </note>
    </para>
    <para>
     All non-linear fitting methods are iterative, and there are two common
     stopping criteria. The first is the number of iterations. 
     If it is not specified with command, value of option 
     <parameter class="option">default-max-iterations</parameter> is used.  
     And the second is the number of evaluations of objective function 
     (<acronym>WSSR</acronym>), specified by value of option 
     <parameter class="option">max-wssr-evaluations</parameter>. 
     It is approximately proportional to time of computations, because most of
     time in fitting process is taken by evaluating <acronym>WSSR</acronym>. 
     There are also other criteria, different for each method. 
     Note that values of all options, even those common for
     all methods, are set separately for every method. 
    </para>
    <para>
     If you give too small <replaceable>n</replaceable> 
     to <command>f.run</command> command, and fit is stopped because of
     it, not because of convergence, it makes sense to use 
     <command>f.continue</command> command to process further iterations. 
     [TODO: how to stop fit interactively] 
    </para>
    <para>
     When fit is running, each iteration outputs some informations. If they are
     scrolling too fast, you can reduce it <replaceable>n</replaceable> times 
     by assigning <replaceable>n</replaceable> 
     to <parameter class="option">output-one-of</parameter> option. 
    </para>
    <para>
     Setting <userinput>o.set autoplot = on-fit-iteration</userinput>
     will draw a plot after every iteration, to visualize progress. 
     (see <link linkend="autoplot">
      <parameter class="option">autoplot</parameter></link>)
    </para>
    <para>
     Command
     <footnote><para>
       Syntax of this command will be changed, other
       error estimates or measures of goodness-of-fit will be added.
     </para></footnote>
     :
     <cmdsynopsis>
      <command>f.info</command> <group><arg>*</arg><arg>**</arg></group> 
     </cmdsynopsis>
     can be used to display <acronym>WSSR</acronym>, 
     symmetric errors and variance-covariance matrix.
    </para>
    <para>
     Available methods can be mixed together, eg. it is
     sensible to obtain initial parameter estimates using simplex method,
     and than fit it using Levenberg-Marquard method. 
     Command <command>s.history</command> can
     be useful for trying various methods with different options and/or
     initial parameters and choosing the best solution.
    </para>
    <para>
     Some fitting methods are using random number generator. In some situations
     one may want to have repeatable and predictable results of fitting, eg.
     to make a presentation. Seed for a new sequence of pseudo-random
     numbers is set at the beginning of fitting initialization 
     (when <command>f.run</command> is called). If value of 
     <parameter class="option">pseudo-random-seed</parameter> 
     option is set to -1, the seed is based on system time and sequence of
     pseudo-random numbers is every time different. In other case, if
     <parameter class="option">pseudo-random-seed</parameter> option has
     a non-negative value, this value is used as a seed. Remember, that like
     all other options, value of 
     <parameter class="option">pseudo-random-seed</parameter> is independent 
     for each fitting method.
    </para>
   </section>

   <section>
    <title>Levenberg-Marquardt </title>
    <para>
     <note>
      <para>
       The rest of this chapter is outdated,
       At this moment default settings of fitting methods can't be changed.
       It will be fixed as soon as possible.
      </para>
     </note>
    </para>
    <para>
     It is a standard of nonlinear least-squares routines. It involves
     computing first derivatives of functions. For description of L-M method
     see <citetitle pubwork="book">Numerical Recipes</citetitle>, chapter 15.5 
     or Siegmund Brandt <citetitle pubwork="book">Data Analysis</citetitle>,
     chapter 10.15 (there is a Polish translation of the second). 
     In a few words: it combines
     inverse-Hessian method (called Gauss-Newton method?) with steepest descent
     method by introducing lambda factor. When lambda is equal 0, the method is
     equivalent to inverse-Hessian method. When lambda increases, the shift
     vector is rotated toward the direction of steepest descent and the length
     of the shift vector decreases. (The shift vector is a vector that is added
     to the parameter vector.) If the better fit is found in iteration, lambda
     is decreased - it is divided by value of 
     <parameter class="option">lambda-down-factor</parameter> option 
     (default: 10). Otherwise, lambda is multiplied by value of 
     <parameter class="option">lambda-up-factor</parameter> (default: 10). 
     You can also change a value of 
     <parameter class="option">lambda-starting-value</parameter> option. 
    </para>
    <para>
     Marquardt method has one stopping criterium apart from common stopping
     criteria. If it happens two times in sequence, that relative 
     progress in value of objective function (<acronym>WSSR</acronym>) 
     is smaller then value of 
     <parameter class="option">stop-rel-change</parameter> option,
     fit is considered to be converged and is stopped. </para>
    <para>
     L-M method finds a minimum quickly. The question is, if it is the
     global minimum.  It can be a good idea to add a small random vector to
     the vector of parameters and try again. This small shift vector is added, 
     when value of <parameter class="option">shake-before</parameter> option 
     is positive (by default it is 0). Value of every parameter's shift 
     is independent and randomly drawn from distribution of type specified by
     value of <parameter class="option">shake-type</parameter> option 
     (see <link linkend="distribtype">option 
      <parameter class="option">distrib-type</parameter></link>)
     in simplex method). The expected value of parameter shift is
     directly proportional to both value of 
     <parameter class="option">shake-before</parameter> option and width of
     parameter's domain.
    </para>
   </section>

   <section>
    <title>Nelder-Mead downhill simplex method </title>
    <para>
     <note>
      <para>
       The rest of this chapter is outdated,
       At this moment default settings of fitting methods can't be changed.
       It will be fixed as soon as possible.
      </para>
     </note>
    </para>
    <para>
     This time I am quoting chapter 4.8.3, p. 86 of Peter Gans
     <citetitle>
      Data Fitting in the Chemical Sciences by the Method of Least Squares 
     </citetitle> 
    </para>
    <blockquote>
     <para>
      A simplex is a geometrical entity that has n+1 vertices corresponding to
      variations in n parameters.  For two parameters the simplex is a
      triangle, for three parameters the simplex is a tetrahedron and so forth.
      The value of the objective function is calculated at each of the
      vertices. An iteration consists of the following process. Locate the
      vertex with the highest value of the objective function and replace this
      vertex by one lying on the line between it and the centroid of the other
      vertices. Four possible replacements can be considered, which I call
      contraction, short reflection, reflection and expansion.[...]
     </para>
     <para>
      It starts with an arbitrary simplex. Neither the shape nor position of
      this are critically important, except insofar as it may determine which
      one of a set of multiple minima will be reached. The simplex than expands
      and contracts as required in order to locate a valley if one exists. Then
      the size and shape of the simplex is adjusted so that progress may be
      made towards the minimum. Note particularly that if a pair of
      parameters are highly correlated, <emphasis>both</emphasis> will be
      simultaneously adjusted in about the correct proportion, as the shape of
      the simplex is adapted to the local contours.[...]
     </para>
     <para>
      Unfortunately it does not provide estimates of the parameter errors, etc.
      It is therefore to be recommended as a method for obtaining initial
      parameter estimates that can be used in the standard least squares
      method.
     </para>
    </blockquote>
    <para>
     This method is also described in previously mentioned 
     <citetitle>Numerical Recipes</citetitle> (chapter 10.4) 
     and <citetitle>Data Analysis</citetitle> (chapter 10.8).
    </para>
    <para>
     After changing current fitting method to Nelder-Mead simplex, what can be
     done, as you already know, either using menu or using command
     <userinput>f.method s</userinput>
     you have a few options specific to this method, that can be changed. 
     One of those is a stopping criterium 
     <parameter class="option">min-fract-range</parameter>. If value of
     expression 2(M-m)/(M+m), where M and m are values of worst and best
     vertices respectively (values of objective functions of vertices, to be
     precise), is smaller then value of 
     <parameter class="option">min-fract-range</parameter> option, fitting is
     stopped. In other words, it is stopped if all vertices are at almost the
     same level.
    </para>
    <para id="distribtype">
     The rest of options is related to initialization of simplex. Before
     starting iterations, we have to chose set of points in space of
     parameters, called vertices.  Unless option 
     <parameter class="option">move-all</parameter> is set, one of these
     points will be the current point - values that parameters have at this
     moment. All but this one are drawn as follows: each parameter of each
     vertex is drawn separately. It is drawn from distribution, that has center
     in center of domain of parameter, and width proportional to both width of
     domain and value of <parameter class="option">move-multiplier</parameter> 
     parameter.  Distribution type can be set using option 
     <parameter class="option">distrib-type</parameter> as one
     of: uniform, Gaussian, Lorentzian and bound. The last one causes value of
     parameter to be either greatest or smallest value in domain of parameter 
     - one of two bounds of domain 
     (assuming that <parameter class="option">move-multiplier</parameter>
     is equal 1).
    </para>
   </section>

   <section>
    <title>Genetic Algorithms</title>
    <para>
     [TODO]
    </para>
   </section>
  </section> 

  <section id="settings">
   <title>Settings </title>
   <para>
    This chapter is not about GUI settings (things like colors,
    fonts, etc.).
   </para>
   <para>
    Command <command>info set</command> shows syntax of the set command
    and lists all possible options.
   </para>
   <para>
    [TODO: this chapter should be expanded...] 
   </para>
  </section> 

  <section>
   <title>Other commands </title>
   <section>
    <title>plot: viewing data</title>
    <para>
     In GUI version there is hardly ever need to use this command directly.
    </para>
    <para>
     Command <command>plot</command> controls visualization of data 
     and the sum.
     It is used to plot given area - in <acronym>GUI</acronym> it is plotted
     in program's main window, in <acronym>CLI</acronym> popular program 
     <application>gnuplot</application> is used, if available. 
     <cmdsynopsis>
      <command>plot</command> 
      <arg><replaceable>xrange</replaceable>
       <arg><replaceable>yrange</replaceable></arg>
      </arg> 
     </cmdsynopsis>
     <replaceable>xrange</replaceable> and <replaceable>yrange</replaceable>
     have one of two following syntaxes:
     <cmdsynopsis>
      <arg choice="req">[</arg> <arg><replaceable>min</replaceable></arg>
      <arg choice="plain">:</arg>
      <arg><replaceable>max</replaceable></arg> <arg choice="req">]</arg>
     </cmdsynopsis>
     <cmdsynopsis>
      <arg choice="plain">.</arg>
     </cmdsynopsis>
     The second is just a dot (.), and it remains appropriate range not changed.
    </para>
    <para>
     Examples:
     <screen>
   plot [20.4:50] [10:20] #plot will show x from 20.4 to 50 and y from 10 to 20

   plot [20.4:] # x from 20.4 to the end, 
                # y range will be fitted to contain all data

   plot . [:10] # x range will not be changed, y from the lowest point to 10 
   plot [:] [:] # all data will be showed.   
   plot         # the same
   plot . .     # nothing changes
     </screen>
    </para>

    <para id="autoplot">
     Value of option <parameter class="option">autoplot</parameter> changes 
     automatic plotting behaviour. By default, plot is refreshed automatically 
     after changing the data or the sum of functions.  
     It is also possible to visualize every iteration of fitting method by
     replotting peaks after every iteration.
    </para>
   </section>
   <section>
    <title>info: show informations</title>
    <para>
     First, there is an option 
     <parameter class="option">verbosity</parameter>
     (not related to command <command>info</command>)
     which decides about amount of messages displayed when executing commands.
    </para>
    <para>
     If you are using GUI, most of informations can be displayed 
     with mouse clicks. Otherwise, you can use <command>info</command>
     command. Using <command>info+</command> instead of <command>info</command>
     sometimes displays more datailed informations.
    </para>
    <para>
     [TODO: list of all info arguments]
    </para>
   </section>
   <section>
    <title>commands, dump, sleep, reset, quit</title>
    <para>
     All commands given during program execution are stored in memory.
     They can be listed using command:
     <command>
      commands [<replaceable>n</replaceable>:<replaceable>m</replaceable>]
     </command> 
     or written to file: 
     <command>
      commands [<replaceable>n</replaceable>:<replaceable>m</replaceable>]
      &gt; <replaceable>filename</replaceable>
     </command>.
    </para>
    <para>
     To log commands to file, when they are executed, use:
     <command>
      commands &gt; <replaceable>filename</replaceable>
     </command> or, to log also output:
     <command>
      commands+ &gt; <replaceable>filename</replaceable>
     </command>.
     To stop logging, use: <command> commands &gt; /dev/null </command>.
    </para>
    <para>
     Scripts can be executed using command:
     <command>
      commands &lt; <replaceable>filename</replaceable>
     </command>.
    </para>
    <para>
     There is also a command
     <command>dump &gt; <replaceable>filename</replaceable></command>,
     [TODO] which is not working at this moment.
    </para>
    <para>
     Command:
     <cmdsynopsis>
      <command>sleep</command> 
      <arg choice="plain"><replaceable>sec</replaceable></arg>
     </cmdsynopsis>
     makes program waiting <replaceable>sec</replaceable> seconds,
     doing nothing. 
    </para>
    <para>
     Command <command>quit</command> works as expected.
    </para>
    <para>
     If option <parameter class="option">exit-on-warning</parameter> 
     is set, any warning will close the program. It ensures, that no warnings
     can be overlooked.
    </para>
   </section> 
  </section> 




  <section id="crystallography">
   <title>Module for crystallography</title>
   <para>
    This module simplifies using <application>fityk</application> 
    for analyzing diffractograms. User must know approximate unit-cell
    parameters, and know or guess Miller's indices of reflections.  
    Widths and shapes of peaks can be independend or angle-depended parameters.
    The whole pattern is refined. Note, that individual profiles can also 
    be fitted, but this module is not needed for it.
   </para>
   <para>
    It is assumed, that x coordinate of data points represent scattering angle
    &two-theta; and wavelengths are constant.
   </para>
   <para>
    Everything, what can be done with crystallographic commands, could be done
    with <command>s.add</command>, <command>s.remove</command>, 
    <command>s.info</command> and <command>m.findpeak</command> commands, 
    although it would be very inconvenient.
   </para>
   <para>
    The wavelength can be specified with command:
    <cmdsynopsis>
     <command>c.wavelength</command> 
     <arg choice="plain"><replaceable>lambda</replaceable></arg> 
     <arg><replaceable>intens</replaceable></arg> 
    </cmdsynopsis>
    <replaceable>lambda</replaceable> and <replaceable>intens</replaceable> 
    are parameters and can be specified as parameters in
    <command>s.add</command> command. 
    It practice, two forms are used: _<replaceable>p</replaceable> 
    (eg. <userinput>_1.93597</userinput>) if wavelength is known 
    or ~<replaceable>p</replaceable> (eg. <userinput>~0.9</userinput>) 
    if it should be fitted.
    <replaceable>intens</replaceable> is a relative intensity of wavelength, 
    and it matters, when there are two or more wavelengths. 
    Above command adds a wavelength with
    its ratio to a set of wavelength. This means, that if you want to define
    two wavelengths, you should use this command twice, and if you want to
    change constant wavelength, you must delete previously defined one and add
    a new one. To delete all defined wavelengths, use command
    <cmdsynopsis>
     <command>c.wavelength</command> <arg choice="plain">!</arg> 
    </cmdsynopsis>
    and to display informations about them, just type:
    <cmdsynopsis>
     <command>c.wavelength</command> 
    </cmdsynopsis>
   </para>
   <para>
    Now about a few essential options. You must choose a peak-shape, that will
    model a reflections. To do this, assign proper value to option 
    <parameter class="option">peak-type</parameter>.
    You can use <link linkend="gaussian">Gaussian</link>, 
    <link linkend="lorentzian">Lorentzian</link>, 
    <link linkend="pearson7">Pearson VII</link>, 
    <link linkend="psvoigt">pseudo-Voigt</link> or Mod-TCHpV.
    The last one is also a pseudo-Voigt, but its width and shape parameters are
    given by following formulae:
    <informalequation>
     <mediaobject>
      <imageobject>
       <imagedata fileref="fitykhelp_img/modtchpv.png"/>
      </imageobject>
      <textobject>
       <phrase>
        complicated Mod-TCHpV formula
       </phrase>
      </textobject>
     </mediaobject>  
    </informalequation>

    Positions (centers) of peaks are determined by Bragg's Law, 
    and heights (and, therefore, areas) are
    fitted almost freely - the only constraint is, 
    that ratio of heights of peaks in one plane is equal to appropriate ratio
    of wavelength intensities. If you do not use Mod-TCHpV type, width and
    shape parameters of peak can be:
    <itemizedlist>
     <listitem>
      <para>
       fitted autonomously for every peak,
      </para>
     </listitem>
     <listitem>
      <para>
       equal for peaks in one plane (if there is more than one wavelength used,
       plane is represented by more than one peak),
      </para>
     </listitem>
     <listitem>
      <para>
       equal for all peaks in one phase,
      </para>
     </listitem>
     <listitem>
      <para>
       or function of &two-theta;; for width, it is Lowe-Ma formula:
       <informalequation>
        <mediaobject>
         <imageobject>
          <imagedata fileref="fitykhelp_img/LoweMa.png"/>
         </imageobject>
         <textobject>
          <phrase>
           H_K^2 = U tan^2 \theta + V tan \theta + W + CT cot^2 \theta 
          </phrase>
         </textobject>
        </mediaobject>  
       </informalequation>
       H<subscript>K</subscript> usually means FWHM, 
       but note that above formula can be also applied to HWHM, by rescaling
       refinable variables: U'=U/4, V'=V/4, etc.
       Shape parameter of peak can be modeled by function of peak's position,
       for pseudo-Voigt peak:
       <informalequation>
        <mediaobject>
         <imageobject>
          <imagedata fileref="fitykhelp_img/a3psvoigt.png"/>
         </imageobject>
         <textobject>
          <phrase>
           a_3 = A + B * (2 \theta)
          </phrase>
         </textobject>
        </mediaobject>  
       </informalequation>
       and for Pearson peak:
       <informalequation>
        <mediaobject>
         <imageobject>
          <imagedata fileref="fitykhelp_img/a3pearson.png"/>
         </imageobject>
         <textobject>
          <phrase>
           a_3 = A + B / (2\theta) + C/(2\theta)^2
          </phrase>
         </textobject>
        </mediaobject>  
       </informalequation>
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    You can select one of possibilities listed above using options
    <parameter class="option">fwhm-constrain</parameter> 
    and <parameter class="option">shape-constrain</parameter>.
   </para>
   <para>
    Phase is defined by its type and lattice parameters. Command
    <cmdsynopsis>
     <command>c.add</command> 
     <arg choice="plain">%<replaceable>p</replaceable></arg> 
     <arg choice="plain"><replaceable>param1</replaceable></arg> 
     <arg rep="repeat"><replaceable>param2</replaceable></arg>
    </cmdsynopsis>
    adds a new phase to set of phases in our model. 
    <replaceable>p</replaceable> is a letter that stands for type of lattice:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <userinput>%c</userinput> - cubic phase,
     </para>
    </listitem>
    <listitem>
     <para>
      <userinput>%t</userinput> - tetragonal phase,
     </para>
    </listitem>
    <listitem>
     <para>
      <userinput>%o</userinput> - orthorhombic phase,
     </para>
    </listitem>
    <listitem>
     <para>
      <userinput>%h</userinput> - hexagonal phase.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Monoclinic and triclinic types are not implemented, 
    because author of program had no need to use them. You can also display 
    this list with command:
    <cmdsynopsis>
     <command>c.info</command> <arg choice="plain">%</arg> 
    </cmdsynopsis>
    Lattice parameters, that follow type of
    phase, can be specified in the same way as 
    <replaceable>lambda</replaceable> and <replaceable>intens</replaceable> in
    <command>c.wavelength</command> command described above. 
   </para>
   <para>
    The last information, which the program needs, is what planes are 
    visible on diffractogram. It has to be specified using Miller 
    indices (hkl).  Command
    <cmdsynopsis>
     <command>c.add</command> 
     <arg>%<replaceable>n</replaceable></arg> 
     <arg choice="plain">(<replaceable>hkl</replaceable>)</arg>
    </cmdsynopsis>
    adds appropriate functions, that represent
    that plane, to the sum of functions. If %<replaceable>n</replaceable> 
    is omitted, first phase (%0) is assumed. Eg. command 
    <userinput>c.add %1 (100)</userinput> will add plane (100) 
    of second defined phase %1. Informations about
    phases and planes can be viewed with command:
    <cmdsynopsis>
     <command>c.info</command> 
     <arg>%<replaceable>n</replaceable> 
      <arg>(<replaceable>hkl</replaceable>)</arg>
     </arg> 
    </cmdsynopsis>
    Every plane or the whole phase can be removed from the model using:
    <cmdsynopsis>
     <command>c.remove</command> 
     <arg choice="plain">%<replaceable>n</replaceable> 
      <arg>(<replaceable>hkl</replaceable>)</arg>
     </arg> 
    </cmdsynopsis>
   </para>
   <para>
    The last thing that requires explanation is how initial height, 
    width and shape parameters of peaks are being found. 
    It is based on algorithm used in 
    m.findpeak command.
    It is also influenced by the same options 
    as <command>m.findpeak</command>. In case of two or more wavelengths used,
    this algorithm is a little enhanced. To see, how peaks representing plane
    will look like, use command:
    <cmdsynopsis>
     <command>c.estimate</command> 
     <arg>%<replaceable>n</replaceable></arg> 
     <arg choice="plain">(<replaceable>hkl</replaceable>)</arg> 
     <arg><replaceable>width</replaceable></arg> 
    </cmdsynopsis>
    If width is given, it is used instead of value of 
    <parameter class="option">search-width</parameter> option.
   </para>

   <section>
    <title>Example</title>
    <para>
     You can find following script and data used by it in 
     <filename class="directory">samples</filename> directory.
     <programlisting>
## this script is an example of crystallography/diffraction module usage

 d.load 'SiC_Zn.dat' # Load data file from current directory (SiC+Zn data)

 #background was obtained by clicking on plot in "background mode"
 d.background  20.4823 43.3474 , 28.004 24.3128 , 31.4412 23.6984 , 
 d.background  33.7911 36.0138 , 38.6477 30.5403 , 98.9835 23.6079 , 
 d.b 98.9835 23.6079 , 79.5965 22.1979 , 65.1888 17.968 , 49.9335 17.263

 d.range [ 31 : ] # only data with 2theta greater then 31.0 are active

 #Used wavelength in known and we do not want to fit it.
 # If you would like to fit wavelength, replace '_' with '~'
 c.w _1.54051 # Cu Ka1 

 c.set peak-type = Mod-TCHpV 

 #define phases and initial lattice parameters
 c.add %c ~4.35  #SiC, %0 
 c.add %h ~2.66  ~4.92  #Zn, %1 

 #defining some peaks (order does not matter)
 c.add %0 (220) # (220) plane of SiC phase
 c.add %1 (002) # (002) plane of Zn phase
 c.add %0 (111)
 c.add %1 (100), %1 (101) # do you remember how comma(,) works?
 c.a %1 (102) # every command can be shortened with x.x (letter-dot-letter)

 #after adding a few peaks, it can be a good idea to fit it, to obtain
 #better approximation of lattice parameters
 #f.run 10 

 # the rest of peaks
 c.add %1 (103), %1(110), %1(112), %1(200), %1(201), %1(202)
 c.add %0 (311)

 s.add &lt;x ~0 #zero-shift

 f.run # running default fitting method (Lev-Mar)
 #'lambda' that you can see in output window is a parameter used by
 # fitting method, not wavelength.

 c.info # see refined lattice parameters
 
 # if you want to zoom, the easiest way is to use left button on auxiliary
 # plot (this plot with difference). To zoom out, use middle button on it.
 # To see individual peaks, select Show->Peaks from pop-up menu.

     </programlisting>
    </para>
   </section> 
  </section> 
 </chapter>

 <appendix id="flist">
  <title>List of functions</title>
  <para>
   To simplify equations, following substitution is introduced:
   <informalequation>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/t_xa1a2.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       t = (x - a1) / a2 
      </phrase>
     </textobject>
    </mediaobject>  
   </informalequation>
   where a<subscript>1</subscript> is a position of peak's center 
   and a<subscript>2</subscript> is a HWHM.

   <equation id="gaussian">
    <title>Gaussian</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/gaussian.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Gaussian" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="lorentzian">
    <title>Lorentzian</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/lorentzian.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Lorentzian" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="pearson7">
    <title>Pearson VII (Pearson7)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/pearson7.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Pearson7" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   <equation id="psvoigt">
    <title>Pseudo-Voigt (PseudoVoigt)</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/pseudo_voigt.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info PseudoVoigt" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   a<subscript>3</subscript> parameters in Pearson VII and Pseudo-Voigt 
   are not related.
   <equation id="voigt">
    <title>Voigt</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/voigt.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Voigt" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
   Voigt function is a convolution of Gaussian and Lorentzian functions.
   a<subscript>0</subscript> = heigth,
   a<subscript>1</subscript> = center,
   a<subscript>2</subscript> is proportional to the Gaussian width, and
   a<subscript>3</subscript> is proportional to the ratio of Lorentzian 
   and Gaussian widths. And t is just a variable of integration.  
   Voigt is computed according to R.J.Wells, 
   <citetitle pubwork="article">
    Rapid approximation to the Voigt/Faddeeva function and its derivatives
   </citetitle>, 
   Journal of Quantitative Spectroscopy &amp; Radiative Transfer 
   62 (1999) 29-48.
   (See also: http://personalpages.umist.ac.uk/staff/Bob.Wells/voigt.html). 
   Is the approximation exact enough for all possible uses of 
   <application>fityk</application> program? 
   <equation>
    <title>Polynomial5</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="fitykhelp_img/polynom5.png"/>
     </imageobject>
     <textobject>
      <phrase> 
       Type in program "info Polynomial5" to see formula.
      </phrase>
     </textobject>
    </mediaobject>  
   </equation>
  </para>
 </appendix>

 <appendix id="license">
  <title>License</title>
  <para>
   <application>Fityk</application> is free software; you can redistribute
   and modify it under terms of GNU General Public License,
   version 2. There is no warranty. 
   <acronym>GPL</acronym> is one of most popular
   licenses, and it is worth reading, if you have not done it
   before. The program is copyrighted by author, and the license
   itself by <acronym>FSF</acronym>. 
   Text of license is distributed with program 
   in file <filename>COPYING</filename>.
  </para>
 </appendix> 

 <appendix>
  <title>About this manual </title>
  <para>
   This manual is written by author of program in DocBook (XML)
   and converted to other formats. All changes, improvements,
   fixes of mistakes, etc. are welcome. 
   The <filename>fitykhelp.xml</filename> file is
   distributed with program sources, and can be modified with any
   text editor. 
  </para>
 </appendix> 

 <bibliography> 
  <biblioentry> 
   <abbrev>1</abbrev>
   <authorgroup>
    <author>
     <surname>Press</surname>  <firstname>William</firstname>
    </author>
    <author>
     <surname>Teukolsky</surname> <firstname>Saul</firstname>
    </author>
    <author>
     <surname>Vetterling</surname> <firstname>William</firstname>
    </author>
    <author>
     <surname>Flannery</surname> <firstname>Brian</firstname>
    </author>
   </authorgroup>
   <title>Numerical Recipes in C</title>
   <address><otheraddr>http://www.nr.com</otheraddr></address>
  </biblioentry>
  <biblioentry> 
   <abbrev>2</abbrev>
   <author>
    <surname>Gans</surname> <firstname>Peter</firstname>
   </author>
   <title>
    Data Fitting in the Chemical Sciences by the Method of Least Squares
   </title>
   <publishername>John Wiley &amp; Sons</publishername>
   <pubdate>1992</pubdate>
  </biblioentry> 
  <biblioentry>
   <abbrev>3</abbrev>
   <author><firstname>Siegmund</firstname><surname>Brandt</surname></author>
   <title>Data Analysis</title>
   <publishername>Springer Verlag</publishername>
   <pubdate>1999</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>4</abbrev>
   <title>PeakFit 4.0 for Windows User's Manual</title>
   <publishername>AISN Software</publishername>
   <pubdate>1997</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>5</abbrev>
   <author>
    <firstname>Zbigniew</firstname><surname>Michalewicz</surname>
   </author>
   <title>Algorytmy genetyczne + struktury danych = programy ewolucyjne</title>
   <publishername>WNT</publishername>
   <pubdate>1996</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>6</abbrev>
   <editor><firstname>R. A.</firstname><surname>Young</surname></editor>
   <title>The Rietveld Method</title>
   <publishername>Oxford University Press</publishername>
   <pubdate>1993</pubdate>
  </biblioentry>
  <biblioentry>
   <abbrev>7</abbrev>
   <author><firstname>R. A.</firstname><surname>Young</surname></author>
   <title>User's Guide to Program DBWS-9807a</title>
   <pubdate>2000</pubdate>
  </biblioentry>
 </bibliography>

</book>
<!-- vim: set ai sw=1 expandtab:  -->

